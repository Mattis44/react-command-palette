import{_ as t,c as a,o as i,ah as o}from"./chunks/framework.CxbIPHq9.js";const p=JSON.parse('{"title":"Accessibility & Keyboard Support","description":"","frontmatter":{},"headers":[],"relativePath":"guide/accessibility.md","filePath":"guide/accessibility.md"}'),s={name:"guide/accessibility.md"};function r(l,e,n,c,h,d){return i(),a("div",null,[...e[0]||(e[0]=[o('<h1 id="accessibility-keyboard-support" tabindex="-1">Accessibility &amp; Keyboard Support <a class="header-anchor" href="#accessibility-keyboard-support" aria-label="Permalink to “Accessibility &amp; Keyboard Support”">​</a></h1><p>The command palette is designed to be accessible out of the box. It follows the <a href="https://www.w3.org/WAI/ARIA/apg/patterns/listbox/" target="_blank" rel="noreferrer">WAI-ARIA best practices for listbox widgets</a> and includes full keyboard navigation.</p><h2 id="keyboard-navigation" tabindex="-1">Keyboard navigation <a class="header-anchor" href="#keyboard-navigation" aria-label="Permalink to “Keyboard navigation”">​</a></h2><ul><li><strong>Arrow Up / Arrow Down</strong> cycle through visible commands.</li><li><strong>Enter</strong> activates the highlighted command.</li><li><strong>Space</strong> also activates the highlighted command when focus is on the list.</li><li><strong>Escape</strong> closes the palette and clears the current query.</li></ul><p>Items expose a visual “active” state so users can see which command will run before pressing Enter.</p><h2 id="focus-management" tabindex="-1">Focus management <a class="header-anchor" href="#focus-management" aria-label="Permalink to “Focus management”">​</a></h2><ul><li>The search input receives focus automatically when the palette opens, allowing users to start typing immediately.</li><li>Calling <code>close()</code> (via hook, API, or clicking the overlay) restores focus to the previously active element thanks to the browser’s default behaviour.</li><li>The <a href="./api.html#methods"><code>focus()</code></a> method lets you refocus the input if you render custom UI inside the palette.</li></ul><h2 id="aria-attributes" tabindex="-1">ARIA attributes <a class="header-anchor" href="#aria-attributes" aria-label="Permalink to “ARIA attributes”">​</a></h2><p>Internally, the palette renders:</p><ul><li><code>role=&quot;listbox&quot;</code> on the command list container.</li><li><code>role=&quot;option&quot;</code> on each command item with <code>aria-selected</code> reflecting the active state.</li><li><code>aria-busy=&quot;true&quot;</code> while async commands are loading, enabling screen readers to announce progress.</li></ul><p>These defaults make the palette usable with screen readers and assistive technology. If you customise the rendering heavily, keep these attributes intact or provide equivalent semantics.</p><h2 id="overlay-interactions" tabindex="-1">Overlay interactions <a class="header-anchor" href="#overlay-interactions" aria-label="Permalink to “Overlay interactions”">​</a></h2><p>The translucent backdrop behind the palette closes it when clicked. You can style it via <a href="./customize.html#customizable-sections"><code>options.overlayStyle</code></a> while keeping the click-to-close behaviour. This gives mouse users a clear escape hatch without relying on keyboard shortcuts.</p><h2 id="helper-text" tabindex="-1">Helper text <a class="header-anchor" href="#helper-text" aria-label="Permalink to “Helper text”">​</a></h2><p>Helper hints (configured through <code>options.helper</code>) are rendered using semantic HTML (<code>&lt;kbd&gt;</code> elements) to describe keyboard keys. This ensures screen readers announce them correctly and they visually match native keyboard shortcuts.</p>',15)])])}const m=t(s,[["render",r]]);export{p as __pageData,m as default};
